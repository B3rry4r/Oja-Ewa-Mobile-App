# Fastfile
# This file contains the fastlane configuration

# Disable analytics
opt_out_usage

# Define the iOS platform
platform :ios do
  desc "Build and upload to TestFlight"
  lane :beta do
    setup_ci

    # Setup keychain for CI
    create_keychain(
      name: "signing_keychain",
      password: ENV['MATCH_KEYCHAIN_PASSWORD'],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    UI.message("Keychain 'signing_keychain' created and unlocked with password from ENV.")

    # Diagnostic: List identities in the new keychain immediately after creation/unlock
    UI.message("--- Listing identities in the newly created keychain (pre-match) ---")
    sh("security find-identity -p codesigning -v #{Actions.lane_context[SharedValues::KEYCHAIN_PATH]}")
    UI.message("--- End identities listing (pre-match) ---")

    # Load App Store Connect API key
    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: './AuthKey.p8'
    )

    # Create the provisioning profiles directory if it doesn't exist
    sh("mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles")
    UI.message("Ensured provisioning profiles directory exists")

    # Get certificates and provisioning profiles with Match
    match(
      type: "appstore",
      keychain_name: Actions.lane_context[SharedValues::KEYCHAIN_PATH], 
      keychain_password: ENV['MATCH_KEYCHAIN_PASSWORD'],
      readonly: true,
      app_identifier: "com.wawuafrica.ojaewa",
      git_url: ENV['MATCH_GIT_URL'],
      git_basic_authorization: Base64.strict_encode64("#{ENV['MATCH_GIT_TOKEN']}:x-oauth-basic"),
      storage_mode: "git",
      api_key: api_key,
      force_for_new_devices: true,
      clone_branch_directly: true
    )
    UI.message("Match completed. Certificates and profiles should now be in keychain.")

    # Diagnostic: List identities again after match to confirm certificate presence
    UI.message("--- Listing identities in the keychain (post-match) ---")
    sh("security find-identity -p codesigning -v #{Actions.lane_context[SharedValues::KEYCHAIN_PATH]}")
    UI.message("--- End identities listing (post-match) ---")

    # Diagnostic: Check if profiles were installed
    UI.message("--- Checking installed provisioning profiles ---")
    sh("ls -la ~/Library/MobileDevice/Provisioning\\ Profiles/ || echo 'Directory exists but is empty'")
    sh("find ~/Library/MobileDevice -name '*.mobileprovision' || echo 'No mobileprovision files found'")
    UI.message("--- End profile check ---")

    # Get profile information from match
    UI.message("Available provisioning profiles from match:")
    UI.message(Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING])
    profile_name = Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]["com.wawuafrica.ojaewa"]
    UI.message("Profile name from match: #{profile_name}")

    # Since match may not install the profile in the standard location on CI,
    # we need to use the profile that match downloaded directly
    # Match stores profiles in the lane context
    sigh_profile_path = Actions.lane_context[SharedValues::SIGH_PROFILE_PATH]
    UI.message("Direct profile path from match: #{sigh_profile_path}")

    # Copy the profile to the standard location if it's not there
    if sigh_profile_path && File.exist?(sigh_profile_path)
      profile_uuid = `grep -a -A 1 'UUID' "#{sigh_profile_path}" | grep string | sed -e 's/<string>//' -e 's/<\\/string>//' -e 's/^[[:space:]]*//'`.strip
      UI.message("Extracted Profile UUID: #{profile_uuid}")
      
      # Copy to standard location
      target_path = File.expand_path("~/Library/MobileDevice/Provisioning Profiles/#{profile_uuid}.mobileprovision")
      sh("cp '#{sigh_profile_path}' '#{target_path}'")
      UI.message("Copied profile to: #{target_path}")
    else
      UI.user_error!("Could not find provisioning profile from match")
    end

    # Update project team
    update_project_team(
      path: "Runner.xcodeproj",
      teamid: ENV['APPLE_TEAM_ID']
    )
    UI.message("Updated project team settings.")

    # Increment build number
    increment_build_number(
      build_number: latest_testflight_build_number(
        api_key: api_key,
        app_identifier: "com.wawuafrica.ojaewa"
      ) + 1,
      xcodeproj: "Runner.xcodeproj"
    )
    UI.message("Build number incremented to avoid TestFlight conflicts.")

    # Build Flutter app
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--release", "--no-codesign")
    end
    UI.message("Flutter build completed (no-codesign).")

    # Manually update Runner target settings via Xcodeproj gem
    require 'xcodeproj'
    project = Xcodeproj::Project.open("../Runner.xcodeproj")

    project.targets.each do |target|
      if target.name == "Runner"
        target.build_configurations.each do |config|
          if config.name == "Release"
            config.build_settings["CODE_SIGN_STYLE"] = "Manual"
            config.build_settings["PROVISIONING_PROFILE_SPECIFIER"] = profile_uuid
            config.build_settings["PROVISIONING_PROFILE"] = profile_uuid
            config.build_settings["DEVELOPMENT_TEAM"] = ENV['APPLE_TEAM_ID']
            config.build_settings["CODE_SIGN_IDENTITY"] = "Apple Distribution"
            config.build_settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] = "Apple Distribution"
          end
        end
      end
    end

    project.save
    UI.message("Updated Runner target code signing settings with UUID: #{profile_uuid}")

    # Build and sign the iOS app
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.wawuafrica.ojaewa" => profile_uuid
        },
        signingStyle: "manual",
        teamID: ENV['APPLE_TEAM_ID'],
        signingCertificate: "Apple Distribution",
        uploadBitcode: false,
        uploadSymbols: true,
        compileBitcode: false
      },
      clean: true,
      verbose: true,
      output_directory: "./build/ios/ipa/",
      silent: false
    )
    UI.message("iOS app built and signed.")

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false,
      skip_submission: false,
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated build from GitHub Actions"
    )
    UI.message("Uploaded to TestFlight.")

    # Clean up keychain
    delete_keychain(name: "signing_keychain")
    UI.message("Keychain deleted.")
  end

  desc "Deploy to App Store"
  lane :release do
    setup_ci

    create_keychain(
      name: "signing_keychain",
      password: ENV['MATCH_KEYCHAIN_PASSWORD'],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    UI.message("Keychain 'signing_keychain' created and unlocked for release lane.")

    # Load App Store Connect API key
    api_key = app_store_connect_api_key(
      key_filepath: "fastlane/apikey.json"
    )

    # Create provisioning profiles directory
    sh("mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles")

    # Get certificates and provisioning profiles with Match
    match(
      type: "appstore",
      keychain_name: "signing_keychain",
      keychain_password: ENV['MATCH_KEYCHAIN_PASSWORD'],
      readonly: true,
      app_identifier: "com.wawuafrica.ojaewa",
      git_url: ENV['MATCH_GIT_URL'],
      git_basic_authorization: Base64.strict_encode64("#{ENV['MATCH_GIT_TOKEN']}:x-oauth-basic"),
      storage_mode: "git",
      api_key: api_key,
      force_for_new_devices: true,
      clone_branch_directly: true
    )
    UI.message("Match completed for release lane.")

    # Get profile path and UUID
    profile_name = Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]["com.wawuafrica.ojaewa"]
    sigh_profile_path = Actions.lane_context[SharedValues::SIGH_PROFILE_PATH]
    
    if sigh_profile_path && File.exist?(sigh_profile_path)
      profile_uuid = `grep -a -A 1 'UUID' "#{sigh_profile_path}" | grep string | sed -e 's/<string>//' -e 's/<\\/string>//' -e 's/^[[:space:]]*//'`.strip
      UI.message("Profile UUID for release: #{profile_uuid}")
      
      target_path = File.expand_path("~/Library/MobileDevice/Provisioning Profiles/#{profile_uuid}.mobileprovision")
      sh("cp '#{sigh_profile_path}' '#{target_path}'")
      UI.message("Copied profile to: #{target_path}")
    else
      UI.user_error!("Could not find provisioning profile for release")
    end

    # Update project team
    update_project_team(
      path: "Runner.xcodeproj",
      teamid: ENV['APPLE_TEAM_ID']
    )
    UI.message("Updated project team settings for release.")

    # Increment build number
    increment_build_number(
      build_number: latest_testflight_build_number(
        api_key: api_key,
        app_identifier: "com.wawuafrica.ojaewa"
      ) + 1,
      xcodeproj: "Runner.xcodeproj"
    )
    UI.message("Build number incremented for release.")

    # Build Flutter app
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--release", "--no-codesign")
    end
    UI.message("Flutter build completed for release.")

    # Update code signing settings
    require 'xcodeproj'
    project = Xcodeproj::Project.open("../Runner.xcodeproj")

    project.targets.each do |target|
      if target.name == "Runner"
        target.build_configurations.each do |config|
          if config.name == "Release"
            config.build_settings["CODE_SIGN_STYLE"] = "Manual"
            config.build_settings["PROVISIONING_PROFILE_SPECIFIER"] = profile_uuid
            config.build_settings["PROVISIONING_PROFILE"] = profile_uuid 
            config.build_settings["DEVELOPMENT_TEAM"] = ENV['APPLE_TEAM_ID']
            config.build_settings["CODE_SIGN_IDENTITY"] = "Apple Distribution"
            config.build_settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] = "Apple Distribution"
          end
        end
      end
    end

    project.save
    UI.message("Updated Runner target code signing settings for release.")

    # Build and sign the iOS app
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.wawuafrica.ojaewa" => profile_uuid
        },
        signingStyle: "manual",
        teamID: ENV['APPLE_TEAM_ID'],
        signingCertificate: "Apple Distribution",
        uploadBitcode: false,
        uploadSymbols: true,
        compileBitcode: false
      },
      clean: true,
      verbose: true,
      output_directory: "./build/ios/ipa/",
      silent: false
    )
    UI.message("iOS app built and signed for release.")

    # Upload to App Store Connect and submit for review
    deliver(
      api_key: api_key,
      submit_for_review: true,
      automatic_release: true,
      force: true,
      skip_metadata: true,
      skip_screenshots: true,
      skip_binary_upload: false,
      ipa: "./build/ios/ipa/Runner.ipa",
      precheck_include_in_app_purchases: false,
      run_precheck_before_submit: false,
      submission_information: {
        export_compliance_uses_encryption: false,
        export_compliance_is_exempt: true,
        export_compliance_contains_third_party_cryptography: false,
        export_compliance_contains_proprietary_cryptography: false,
        export_compliance_available_on_french_store: true
      }
    )
    UI.message("Submitted to App Store for review.")

    # Clean up keychain
    delete_keychain(name: "signing_keychain")
    UI.message("Keychain deleted after release.")
  end

  error do |lane, exception|
    delete_keychain(name: "signing_keychain") if File.exist?(File.expand_path("~/Library/Keychains/signing_keychain-db"))
    UI.message("Error occurred: #{exception.message}")
  end
end
